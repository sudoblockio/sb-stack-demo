# JSON-RPC Service

This document describes the JSON-RPC 2.0 service built on the HTTP transport layer.

## Architecture Overview

The JSON-RPC service follows a layered architecture built on the HTTP transport:

```
┌─────────────────────────────────────────┐
│ JSON-RPC Service                        │  ← Protocol-specific implementation
│ (with optional service middleware)      │
├─────────────────────────────────────────┤
│ HTTP Transport (sb-stack-transport-http)│  ← Transport layer
│ (with optional transport middleware)    │
├─────────────────────────────────────────┤
│ Network                                 │  ← Network communication
└─────────────────────────────────────────┘
```

**Request Flow:** JSON-RPC Service → [Service Middleware] → HTTP Transport → [Transport Middleware] → Network

**Response Flow:** Network → [Transport Middleware] → HTTP Transport → [Service Middleware] → JSON-RPC Service

## Usage

### 1.1 Rust

```rust
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_jsonrpc_types::{JsonRpcServiceRequest, JsonrpcId};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = JsonRpcServiceConfig::new("https://httpbin.org/post");
    let mut service = JsonRpcService::new(config)?;
    service.connect().await?;

    let request = JsonRpcServiceRequest {
        id: JsonrpcId::Number(1),
        method: "echo".to_string(),
        params: Some(json!({"text": "hello"})),
        url: None,
        headers: HeaderMap::new(),
        extra: HashMap::new(),
        extensions: Extensions::new(),
        _response_type: std::marker::PhantomData::<serde_json::Value>,
    };

    let responses = service.call(vec![request]).await?;

    for response in responses {
        if let Some(result) = response.result {
            println!("Result: {}", result);
        }
    }

    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_jsonrpc_client import JsonRpcClient

async def main():
    client = JsonRpcClient("https://httpbin.org/post")
    await client.connect()
    
    response = await client.call("echo", {"text": "hello"})
    
    if response.is_success():
        result = response.into_result()
        print(f"Result: {result}")
    else:
        print(f"Error: {response.error}")
    
    await client.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { JsonRpcClient } from 'sb-jsonrpc-client';

async function main() {
    const client = new JsonRpcClient({
        url: 'https://httpbin.org/post'
    });
    
    await client.connect();
    
    const response = await client.call('echo', { text: 'hello' });
    
    if (response.isSuccess()) {
        const result = response.intoResult();
        console.log('Result:', result);
    } else {
        console.log('Error:', response.error);
    }
    
    await client.close();
}

main().catch(console.error);
```

## Middleware

### 1.1 Rust

```rust
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_logging_middleware::{LoggingMiddleware, LogLevel};
use sb_stack_jsonrpc_types::{JsonRpcServiceRequest, JsonrpcId};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let logging = LoggingMiddleware::new(LogLevel::Info)
        .with_request_params(true)
        .with_response_results(true);

    let config = JsonRpcServiceConfig::new("https://httpbin.org/post")
        .with_middleware(logging);

    let mut service = JsonRpcService::new(config)?;
    service.connect().await?;

    let request = JsonRpcServiceRequest {
        id: JsonrpcId::Number(1),
        method: "echo".to_string(),
        params: Some(json!({"text": "hello"})),
        url: None,
        headers: HeaderMap::new(),
        extra: HashMap::new(),
        extensions: Extensions::new(),
        _response_type: std::marker::PhantomData::<serde_json::Value>,
    };

    let responses = service.call(vec![request]).await?;

    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_jsonrpc_client import JsonRpcClient, LoggingMiddleware, LogLevel

async def main():
    logging = LoggingMiddleware(
        level=LogLevel.INFO,
        log_request_params=True,
        log_response_results=True
    )
    
    client = JsonRpcClient("https://httpbin.org/post", middlewares=[logging])
    await client.connect()
    
    response = await client.call("echo", {"text": "hello"})
    
    print(f"Response ID: {response.id()}")
    print(f"Is success: {response.is_success()}")
    print(f"Is error: {response.is_error()}")
    
    if response.is_success():
        result = response.into_result()
        print(f"Result: {result}")
    
    await client.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { JsonRpcClient, LoggingMiddleware, LogLevel } from 'sb-jsonrpc-client';

const logging = new LoggingMiddleware({
    level: LogLevel.INFO,
    logRequestParams: true,
    logResponseResults: true
});

async function main() {
    const client = new JsonRpcClient({
        url: 'https://httpbin.org/post',
        middlewares: [logging]
    });
    
    await client.connect();
    
    const response = await client.call('echo', { text: 'hello' });
    
    console.log('Response ID:', response.id());
    console.log('Is success:', response.isSuccess());
    console.log('Is error:', response.isError());
    
    if (response.isSuccess()) {
        const result = response.intoResult();
        console.log('Result:', result);
    }
    
    await client.close();
}

main().catch(console.error);
```

## Batch Processing

JSON-RPC batch processing for multiple requests in a single call.

### 1.1 Rust

```rust
use sb_stack_jsonrpc_batch::{BatchService, BatchConfig};
use sb_stack_jsonrpc::{JsonRpcService, JsonRpcServiceConfig};
use sb_stack_jsonrpc_types::JsonRpcServiceRequest;
use serde_json::json;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let jsonrpc_service = JsonRpcService::new(
        JsonRpcServiceConfig::new("https://httpbin.org/post")
    )?;

    let batch_config = BatchConfig {
        max_batch_size: 50,
        max_pending_instructions: 1000,
    };

    let batch_service = BatchService::new(jsonrpc_service, batch_config);
    let handle = batch_service.handle();

    let request = JsonRpcServiceRequest::new("echo", Some(json!({"text": "hello"})));

    let mut batch = handle.new_batch();
    batch.add_request(JsonRpcServiceRequest::new("method1", Some(json!({"param": "value1"}))));
    batch.add_request(JsonRpcServiceRequest::new("method2", Some(json!({"param": "value2"}))));
    let batch_responses = batch.send().await?;

    Ok(())
}
```

### 1.2 Python

```python
import asyncio
from sb_jsonrpc_client import BatchClient, BatchConfig

async def main():
    config = BatchConfig(
        max_batch_size=50,
        max_pending_instructions=1000
    )
    
    client = BatchClient("https://httpbin.org/post", config=config)
    await client.connect()
    
    
    batch = client.new_batch()
    batch.add_request("method1", {"param": "value1"})
    batch.add_request("method2", {"param": "value2"})
    batch.add_request("method3", {"param": "value3"})
    
    responses = await batch.send()
    
    for response in responses:
        if response.is_success():
            print(f"Result: {response.into_result()}")
        else:
            print(f"Error: {response.error}")
    
    await client.close()

asyncio.run(main())
```

### 1.3 TypeScript

```typescript
import { BatchClient, BatchConfig } from 'sb-jsonrpc-client';

async function main() {
    const config = new BatchConfig({
        maxBatchSize: 50,
        maxPendingInstructions: 1000
    });
    
    const client = new BatchClient({
        url: 'https://httpbin.org/post',
        config: config
    });
    
    await client.connect();
    
    const batch = client.newBatch();
    batch.addRequest('method1', { param: 'value1' });
    batch.addRequest('method2', { param: 'value2' });
    batch.addRequest('method3', { param: 'value3' });
    
    const responses = await batch.send();
    
    for (const response of responses) {
        if (response.isSuccess()) {
            console.log('Result:', response.intoResult());
        } else {
            console.log('Error:', response.error);
        }
    }
    
    await client.close();
}

main().catch(console.error);
```

## Configuration

The JSON-RPC service supports configuration for transport settings, timeouts, and connection management.

#### 1.1 Rust

```rust
use sb_stack_jsonrpc::JsonRpcServiceConfig;
use sb_stack_transport_http::Http1TransportConfig;
use sb_stack_transport_types::ConnectionConfig;
use std::time::Duration;

let transport_config = Http1TransportConfig {
    timeout: Some(Duration::from_secs(30)),
    connection_config: ConnectionConfig {
        pool_max_idle_per_host: 32,
        pool_idle_timeout: Some(Duration::from_secs(90)),
        tcp_keepalive: Some(Duration::from_secs(60)),
        ..Default::default()
    },
    ..Default::default()
};

let mut config = JsonRpcServiceConfig::new("https://httpbin.org/post");
config.config = Some(transport_config);
```

#### 1.2 Python

```python
from sb_jsonrpc_client import JsonRpcClient, Http1TransportConfig, ConnectionConfig

transport_config = Http1TransportConfig(
    timeout=30.0,
    connection_config=ConnectionConfig(
        pool_max_idle_per_host=32,
        pool_idle_timeout=90.0,
        tcp_keepalive=60.0
    )
)

client = JsonRpcClient(
    "https://httpbin.org/post",
    config=transport_config
)
```

#### 1.3 TypeScript

```typescript
import { 
    JsonRpcClient, 
    Http1TransportConfig, 
    ConnectionConfig 
} from 'sb-jsonrpc-client';

const transportConfig = new Http1TransportConfig({
    timeout: 30000,
    connectionConfig: new ConnectionConfig({
        poolMaxIdlePerHost: 32,
        poolIdleTimeout: 90000,
        tcpKeepalive: 60000
    })
});

const client = new JsonRpcClient({
    url: 'https://httpbin.org/post',
    config: transportConfig
});
```
